%Dokumentinformationen
\newcommand{\titleinfo}{ProgGru - Zusammenfassung}
\newcommand{\authorinfo}{L. Leuenberger}
\newcommand{\versioninfo}{$Revision: $ \today}

% standard header
\include{sections/header} % ./header.tex nicht editieren (Projekt LaTeX-Header benutzen)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Neue Befehle und Definitionen                
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This is needed for one more subsection, ex. 1.1.1.1, is called by \paragraph{}
\usepackage{titlesec}
\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}
\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
% Settings which are used to set the distance above and under the sections
\titlespacing*{\paragraph}{0pt}{2.25ex plus 1ex minus .2ex}{1.0ex plus .2ex}
\titlespacing{\section}{0em}{0.5em}{0.5em}
\titlespacing{\subsection}{0em}{0.5em}{0.5em}
\titlespacing{\subsubsection}{0em}{0.5em}{0.5em}

% Linksbündig
\setlength\parindent{0ex}

% This is needed for a smaller itemlist, is called by \compactenum {}
\usepackage{paralist}

% This is needed for merging some columns in a table
\usepackage{multicol} 
\usepackage{multirow}

% This is needed for code listing
\usepackage{listings}

\definecolor{red}{rgb}{1,0,0}
\newcommand{\verweis}[1]{$_{\textcolor{red}{\mbox{\small{Kapitel #1}}}}$}
\newcommand{\verweishoch}[1]{${\textcolor{red}{\mbox{\small{Kapitel #1}}}}$}

%Document Anfang
\begin{document}	
\section{Vom Problem zum Programm \verweis{1.2}}
	\subsection{Algorithmus}
		Der Begriff Programm ist eng mit dem Begriff Algorithmus verbunden. Algorithmen sind Vorschriften für die Lösung eines Problemes, welches die Handlungen und ihre Abfolge, also die Handlungsweise, beschreiben. Abstrakt kann man sagen, dass die folgenden Bestandteile und Eigenschaften zu einem Algorithmus gehören: \textit{(am Beispiel eines Kochrezeptes erklärt)} 
		\begin{compactitem}
			\item eine \textbf{Menge von Objekten}, die durch den Algorithmus bearbeitet werden \textit{(Zutaten, Geschirr, Herd, \dots)}
			\item eine \textbf{Menge von Operationen}, die auf den Objekten ausgeführt werden \textit{(waschen, schälen, \dots)}
			\item ein \textbf{definierter Anfangszustand}, in dem sich die Objekte zu Beginn befinden \textit{(Teller leer, Herd kalt, \dots)}
			\item ein \textbf{gewünschter Endzustand}, in dem sich die Objekte nach der Lösung des Problems befinden sollen \textit{(gekochtes Gemüse, \dots)}
		\end{compactitem}	

	\subsection{Der euklidische Algorithmus als Beispiel}
		\subsubsection{Das Problem}
				Eine rechteckige Terrasse sei mit möglichst grossen quadratischen Platten auszulegen. Welche Kantenlänge haben die Platten?
			
		\begin{minipage}[t]{9 cm}
			\subsubsection{Der Algorithmus}
				\includegraphics[width=1.0\textwidth]{pics/Euklid.jpg}
							
				Mit Abschneidetechnik nach Euklid. Entspricht der \\
				Ermittlung des grössten gemeinsamen Teilers (ggT): \\
				$\frac{x_{ungek"urzt}}{y_{ungek"urzt}}=\frac{\frac{x_{ungek"urzt}}{ggT(x_{ungek"urzt},y_{ungek"urzt})}}{\frac{y_{ungek"urzt}}{ggT(x_{ungek"urzt},y_{ungek"urzt})}}=\frac{x_{gek"urzt}}{y_{gek"urzt}}$ \\
					
			\subsubsection{Algorithmus-Beschreibung mit Struktogramm \verweis{1.3}}
				\includegraphics[width=1.0\textwidth]{pics/Euklid_Struktogramm.jpg}

		\end{minipage}
		%
		\begin{minipage}[t]{9 cm}	
			\subsubsection{Algorithmus-Beschreibung mit Pseudocode \verweis{1.2.1}}
				\lstinputlisting[language=C,tabsize=2]{code/Euklid_Pseudo.c}
					
				\subsubsection{Programm}
					\lstinputlisting[language=C,tabsize=2]{code/Euklid.c}
							
				\subsubsection{Trace-Tabelle \verweis{1.2.4}}
					\includegraphics[width=0.58\textwidth]{pics/Euklid_Trace.jpg}
	
		\end{minipage}
		
\newpage
		
	\subsection{Nassi-Shneiderman-Diagramme \verweis{1.3}}
		Zur Visualisierung des Kontrollflusses von Programmen, das heisst, zur grafischen Veranschaulichung ihres Ablaufes, wurden 1973 von Nassi und Shneiderman grafische Strukturen, die sogenannten Struktogramme, vorgeschlagen. Entwirft man Programme mit Nassi-Shneiderman-Diagrammen, so genügt man automatisch den Regeln der Strukturierten Programmierung.
		
		\begin{minipage}[t]{6 cm}
			\subsubsection{Sequenz}
				\includegraphics[width=1\textwidth]{pics/Nassi_Sequenz.jpg}
				
			\subsubsection{Block}
				\includegraphics[width=1\textwidth]{pics/Nassi_Block.jpg}	
					
			\subsubsection{Einfache Alternative}
				\includegraphics[width=1\textwidth]{pics/Nassi_einfache_Alternative.jpg}
					
		\end{minipage}
		%
		\begin{minipage}[t]{6 cm}
			\subsubsection{Bedingte Anweisung}
				\includegraphics[width=1\textwidth]{pics/Nassi_bedingte_Verarbeitung.jpg}
								
			\subsubsection{Mehrfache Alternative}
				\includegraphics[width=1\textwidth]{pics/Nassi_mehrfache_Alternative.jpg}	
									
			\subsubsection{Schleife mit vorheriger Prüfung}
				\includegraphics[width=1\textwidth]{pics/Nassi_While.jpg}
					
		\end{minipage}
		%
		\begin{minipage}[t]{6 cm}
			\subsubsection{Endlosschlaufe}
				\includegraphics[width=1\textwidth]{pics/Nassi_While1.jpg}
											
			\subsubsection{Schleife mit nachfolgender Prüfung}
				\includegraphics[width=1\textwidth]{pics/Nassi_DoWhile.jpg}	
					
			\subsubsection{Abbruchanweisung}
				\includegraphics[width=1\textwidth]{pics/Nassi_Break.jpg}	
								
		\end{minipage}
		
\section{Kontrollstrukturen \verweis{8}}
	\begin{minipage}[t]{9 cm}
		\subsection{Sequenz \verweis{8.1}}
			Die Sequenz ist eine zeitlich geordnete Abfolge von Anweisungen. \\
				\includegraphics[width=1\textwidth]{pics/Sequenz.jpg}	
			
	\end{minipage}
	%
	\begin{minipage}[t]{9 cm}
			\subsubsection{Block}
				\begin{compactitem}
					\item Erfordert die Syntax genau eine Anweisung, so können dennoch mehrere Anweisungen geschrieben werden, wenn man sie in Form eines Blocks zusammenfasst.
					\item Ein Block wird mit geschweiften Klammern eingefasst. $\{ \dots \}$ Ein Block zählt syntaktisch als eine einzige Anweisung.
				\end{compactitem}
				\includegraphics[width=1\textwidth]{pics/Block.jpg}
	\end{minipage}	
		
	\subsection{Selektion \verweis{8.2}}
		Von \textbf{Selektion} spricht man zum einen, wenn man eine Anweisung nur dann ausführen will, wenn eine bestimmte Bedingung zutrifft. Zum anderen möchte man mit Selektionsanweisungen zwischen zwei Möglichkeiten (entweder/oder) bzw. zwischen mehreren Möglichkeiten genau eine auswählen.
		
		\begin{minipage}[t]{5.5 cm}
			\subsubsection{Einfache Alternative}
				\lstinputlisting[language=C,tabsize=2]{code/strukturen_if_else.c}
		\end{minipage}
		%
		\begin{minipage}[t]{5.5 cm}
			\subsubsection{Bedingte Anweisung}
				\lstinputlisting[language=C,tabsize=2]{code/strukturen_if.c}
		\end{minipage}
		%
		\begin{minipage}[t]{7 cm}
			\subsubsection{Mehrfache Alternative - else if}
				\lstinputlisting[language=C,tabsize=2]{code/strukturen_else_if.c}
		\end{minipage}
		
\newpage

		\subsubsection{Mehrfache Alternative - switch case}
			\begin{minipage}[t]{9 cm}
				
				\begin{compactitem}
					\item Für eine Mehrfach-Selektion, d.h. eine Selektion unter mehreren Alternativen, kann die $switch$-Anweisung verwendet werden, falls die Alternativen ganzzahligen Werten eines Ausdrucks von einem Integer-Typ entsprechen.
					\item Hat der Ausdruck der $switch$-Anweisung den gleichen Wert wie einer der konstanten Ausdrücke der $case$-Marken, wird die Ausführung des Programms mit der Anweisung hinter dieser $case$-Marke weitergeführt.
					\item Stimmt keiner der konstanten Ausdrücke mit dem $switch$-Ausdruck überein, wird zu $default$ gesprungen.
				\end{compactitem}							
			\end{minipage}
			\hspace*{1cm}
			\begin{minipage}[t]{9 cm}
				\vspace*{-0.5cm}
				\lstinputlisting[language=C,tabsize=2]{code/strukturen_switch.c}
			\end{minipage}
			
	\subsection{Iteration \verweis{8.3}}
		\begin{minipage}[t]{4 cm}
			\subsubsection{While}
				\lstinputlisting[language=C,tabsize=2]{code/strukturen_while.c}
		\end{minipage}
		%
		\begin{minipage}[t]{10 cm}
			\subsubsection{For-Schleife}
				\lstinputlisting[language=C,tabsize=2]{code/strukturen_for.c}
		\end{minipage}
		%
		\begin{minipage}[t]{5 cm}
			\subsubsection{Do-While}
				\lstinputlisting[language=C,tabsize=2]{code/strukturen_dowhile.c}
		\end{minipage}
		
		\subsubsection{Endlosschleife}
			\begin{minipage}[c]{3 cm}
				\lstinputlisting[language=C,tabsize=2]{code/strukturen_endlos_for.c}
			\end{minipage}
			%
			\begin{minipage}[c]{3 cm}
				\lstinputlisting[language=C,tabsize=2]{code/strukturen_endlos_while.c}
			\end{minipage}
		
		\subsubsection{Wann wird welche Schleife eingesetzt?}
			\begin{compactitem}
				\item For-Schleife: Bei Zählschleifen, d.h. wenn die Anzahl Durchläufe (kann auch variabel sein) im
				voraus feststeht.
				\item Do-While-Schleife: Wenn es keine Zählschleife ist, und die Schleife muss mindestens einmal
				durchlaufen werden
				\item While-Schleife: In allen anderen Fällen
			\end{compactitem}
			
	\subsection{Sprunganweisungen \verweis{8.4}}
		\begin{compactitem}
			\item break: $do-while$-, $while$-,  $for$-Schleife und $switch$-Anweisung abbrechen
			\item continue: in den nächsten Schleifendurchgang (Schleifenkopf) springen bei $do-while$-, $while$- und $for$-Schleife 
			\item return: aus Funktion an aufrufende Stelle zurückspringen
			\item goto: innerhalb einer Funktion an eine Marke (Label) springen
		\end{compactitem}
		
\section{Typenkonzept \verweis{5}}
	In C wird verlangt, dass alle Variablen einen genau definierten, vom Programmierer festgelegten Typ haben. Der Typ bestimmt, welche werte eine Variable annehmen kann und welche nicht.
	
	\subsection{Übersicht über alle Standard-Datentypen \verweis{5.2}}
		\begin{tabular}{|c|c|c|c|c|}
				\hline
					\textbf{Datentyp} & \textbf{Anzahl Bytes} & \textbf{Wertebereich (dezimal)} & Typ & Verwendung\\
				\hline
				\hline
					$char$ & 1 & $-128$ bis $+127$ & Ganzzahltyp & speichern eines Zeichens\\
				\hline
					$unsigned$ $char$ & 1 & $0$ bis $+255$ & Ganzzahltyp & speichern eines Zeichens\\
				\hline
					$signed$ $char$ & 1 & $-128$ bis $+127$ & Ganzzahltyp & speichern eines Zeichens\\
				\hline
				\hline
					$int$ & 4 (in der Regel) & $-2'147'483'648$ bis $+2'147'483'647$ & Ganzzahltyp & effizienteste Grösse\\
				\hline
					$unsigned$ $int$ & 4 (in der Regel) & $0$ bis $+4'294'967'295$ & Ganzzahltyp & effizienteste Grösse\\
				\hline
				\hline
					$short$ $int$ & 2 (in der Regel) & $-32'768$ bis $+32'767$ & Ganzzahltyp & kleine ganzzahlige Werte\\
				\hline
					$unsigned$ $short$ $int$ & 2 (in der Regel) & $0$ bis $+65'535$ & Ganzzahltyp & kleine ganzzahlige Werte\\
				\hline
				\hline
					$long$ $int$ & 4 (in der Regel) & $-2'147'483'648$ bis $+2'147'483'647$ & Ganzzahltyp & grosse ganzzahlige Werte\\
				\hline
					$unsigned$ $long$ $int$ & 4 (in der Regel) & $0$ bis $+4'294'967'295$ & Ganzzahltyp & grosse ganzzahlige Werte\\
				\hline
				\hline
					$float$ & 4 (in der Regel) & $-3.4*10^{38}$ bis $+3.4*10^{38}$ & Gleitpunkttyp & Gleitpunktzahl\\
				\hline
					$double$ & 8 (in der Regel) & $-1.7*10^{308}$ bis $+1.7*10^{308}$ & Gleitpunkttyp & höhere Genauigkeit\\
				\hline
					$long$ $double$ & 4 (in der Regel) & $-1.1*10^{4932}$ bis $+1.1*10^{4932}$ & Gleitpunkttyp & noch höhere Genauigkeit\\
				\hline
			\end{tabular}
		
\newpage

		\subsubsection{Ganzzahltypen (Integertypen) \verweis{5.2}}
			\begin{compactitem}
				\item Alle Integertypen ausser $char$ sind per Default vorzeichenbehaftet.
				\item Bei $char$ ist es compilerabhängig.
				\item Voranstellen des Schlüsselwortes $unsigned$ bewirkt, dass alle Bits für eine positive Zahl verwendet werden. (keine negativen Zahlen möglich)
				\item Eine Überlaufproblematik (Overflow) bei $signed$ und $unsigned$ Typen ist vorhanden. Überläufe müssen vom Programmierer abgefangen werden!
				\item Die Werte werden bei $unsigned$ Typen im Zweierkomplement abgespeichert.
			\end{compactitem}
			
		\subsubsection{Gleitpunkttypen \verweis{5.2}}
			\begin{compactitem}
				\item Gleitpunkttypen sind sehr viel aufwendiger in der Berechnung als Integertypen.
				\item Speziell bei kleinen Microcontrollern ohne FPU (floating point unit) sollte wenn möglich auf Gleitpunkttypen verzichtet werden.
				\item Die Werte werden gemäss Floating Point Standart IEEE 754 abgespeichert. Die Berechnung ist zu finden im \verweishoch{5.2.3}.
			\end{compactitem}
			
	\subsection{Variablen \verweis{5.3}}
		\begin{compactitem}
			\item Deklaration: legt nur die Art und den Typ der Variable, bzw. die Schnittstelle der Funktion fest ohne Speicherplatz zu reservieren
			\item Definition: legt die Art und den Typ der Variablen bzw. Funktionen fest und reserviert Speicherplatz dafür \\
			\textbf{Definition = Deklaration + Reservierung des Speicherplatzes} 
		\end{compactitem}
		
	\begin{minipage}[t]{9 cm}
		\subsubsection{Definition von Variablen \verweis{5.3.1}}
			Eine einzelne Variable wird definiert durch eine Vereinbarung der Form:
			\lstinputlisting[language=C,tabsize=2]{code/variablen_definition_1.c}
			also beispielsweise durch
			\lstinputlisting[language=C,tabsize=2]{code/variablen_definition_2.c}
			Vom selben Typ können auch mehrere Variablen gleichzeitig definiert werden:
			\lstinputlisting[language=C,tabsize=2]{code/variablen_definition_3.c}
	\end{minipage}
	\hspace*{0.5cm}
	\begin{minipage}[t]{9 cm}
		\subsubsection{Interne und externe Variablen \verweis{5.3.2}}
			\begin{compactitem}
				\item Globale (externe) Variablen: Diese Variablen stehen allen Funktionen zur Verfügung und müssen ausserhalb von Funktionen definiert werden.
				\item Lokale (interne) Variablen: Diese Variablen stehen nur der Funktion zur Verfügung, in welcher die definiert wurden. Sie kann nicht von ausserhalb angesprochen werden.
			\end{compactitem}
			
			\ \\
			\textbf{Grundsätzlich gilt: Variablen so lokal wie möglich definieren!}
	\end{minipage}	
	
	\begin{minipage}[t]{9 cm}
		\subsubsection{Manuelle Initialisierung von Variablen \verweis{5.3.3}}
			Jede einfache Variable kann bei ihrer Definition initialisiert werden:
			\lstinputlisting[language=C,tabsize=2]{code/variablen_init.c}
	\end{minipage}
	\hspace*{0.5cm}
	\begin{minipage}[t]{9 cm}	
		\subsubsection{Automatische Initialisierung von Variablen \verweis{5.3.3}}
			\begin{compactitem}
				\item Globale Variablen werden beim Programmstart immer auf Null gesetzt.
				\item Lokale Variablen werden \textbf{nicht} automatisch initialisiert und enthalten einen zufälligen Wert.
			\end{compactitem}					
	\end{minipage}		
	
		Es ist zu empfehlen, immer alle Variablen (lokal und global) vor dem ersten Lesezugriff manuell zu initialisieren.
		
	\subsubsection{Sichtbarkeit von Variablen \verweis{9.2}}
		Die Sichtbarkeit einer Variablen bedeutet, dass man auf sie über ihren Namen zugreifen kann:
		
		\begin{compactitem}
			\item Variablen in inneren Blöcken sind nach aussen nicht sichtbar.
			\item Globale Variablen und Variablen in äusseren Blöcken sind in inneren Blöcken sichtbar.
			\item Wird in einem Block eine lokale Variable definiert mit demselben Namen wie eine globale Variable oder wie eine Variable in einem umfassenden Block, so ist innerhalb des Blocks nur die lokale Variable sichtbar. Die globale Variable in dem umfassenden Block wird durch die Namensgleichheit verdeckt.
			\item Wird in einem Block eine lokale Variable definiert mit demselben Namen wie eine Funktion, so ist innerhalb des Blockes nur die lokale Variable sichtbar. Die Funktion wird durch die Namensgleichheit verdeckt, da Funktionen denselben Namensraum wie Variablen haben.
		\end{compactitem}
			
	\subsection{Typ-Attribute \verweis{5.4}}
		\begin{compactitem}
			\item const: Die Variable kann nur initialisiert werden. Weitere Änderungen sind nicht mehr
			möglich.
			\lstinputlisting[language=C,tabsize=2]{code/konstante_init.c}
			\item volatile: Die Variable wird nicht (weg-)optimiert durch den Compiler, d.h. die Adressen der Variablen werden nicht geändert. Dies wird benötigt, wenn eine Variable auf einer definierten Adresse liegen muss (z.B. Memory-Mapped-Input/Output bei einem Mikrocontroller)
		\end{compactitem}
		\newpage	
	\subsection {Klassifikation von Datentypen \verweis{5.5 und Kapitel 5.6}}
		\begin{minipage}[c]{9 cm}
			\includegraphics[width=1\textwidth]{pics/datentypen_klassifikation.jpg}
		\end{minipage}
		%
		\begin{minipage}[c]{10 cm}
			In der Programmiersprache C gibt es drei Klassen von Typen:
			\begin{compactitem}
				\item Objekttypen (Datentypen): Objekttypen beschreiben Variablen, \\
				z.B. $int$
				\item Funktionstypen: Funktionstypen beschreiben Funktionen, \\
				z.B. $int$ $f$ $(void)$
				\item unvollständige Typen: Der Typ $void$ ist ein unvollständiger Typ, der nicht vollständig gemacht werden kann. Er bezeichnet eine leere Menge und wird beispielsweise verwendet, wenn eine Funktion keinen Rückgabewert oder keine Übergabeparameter hat.
			\end{compactitem}
		\end{minipage}
	
\section{Funktionen}
	\subsection{Aufgaben einer Funktion}
		\begin{compactitem}
			\item Gleichartige, funktional zusammengehörende Programmteile unter einem eigenen Namen zusammenfassen. Der Programmteil kann mit diesem Namen aufgerufen werden.
			\item Einige Funktionen (im speziellen mathematische) sollen parametrisiert werden können, z.B. die Cosinusfunktion macht nur Sinn, wenn sie mit unterschiedlichen Argumenten aufgerufen werden kann.
			\item Divide et impera (divide and conquer, teile und herrsche): Ein grosses Problem ist einfacher zu lösen, wenn es in mehrere einfachere Teilprobleme aufgeteilt wird.
		\end{compactitem}	
		
	\subsection{Definition von Funktionen \verweis{9.3.1}}
		\begin{minipage}[c]{10 cm}
			\includegraphics[width=1\textwidth]{pics/funktionen_aufbau.jpg}
		\end{minipage}
		%
		\begin{minipage}[c]{9 cm}
			\begin{compactitem}
				\item Funktionskopf: legt die Aufrufschnittstelle (Signatur) der Funktion fest. Er besteht aus Rückgabetyp, Funktionsname und Parameterliste.
				\item Funktionsrumpf: Lokale Vereinbarungen und Anweisungen innerhalb eines Blocks
			\end{compactitem}	
		\end{minipage}	
			
	\subsection{Eingaben/Ausgaben einer Funktion \verweis{9.3}}
		\begin{minipage}[t]{8.5 cm}
			\subsubsection{Eingabedaten}
				Es sind folgende Möglichkeiten vorhanden um Daten an Funktionen zu übergeben:
				\begin{compactitem}
					\item Mithilfe von Werten, welche an die Parameterliste übergeben werden
					\item Mithilfe von globalen Variablen
				\end{compactitem}
		\end{minipage}
		\hspace*{0.5cm}
		\begin{minipage}[t]{8.5 cm}
			\subsubsection{Ausgabedaten}
				Es sind folgende Möglichkeiten vorhanden um Daten zurückzugeben:
				\begin{compactitem}
					\item Mithilfe des Rückgabewertes einer Funktion ($return$)
					\item Mithilfe von Änderungen an Variablen, deren Adresse über die Parameterliste an die Funktion übergeben wurde
					\item Mithilfe von Änderungen an globalen Variablen
				\end{compactitem}	
		\end{minipage}	
		
		\subsubsection{Beispiele}
			\begin{minipage}[t]{8.5 cm}
				\textbf{Parameterlos und ohne Rückgabewert:}
				\lstinputlisting[language=C,tabsize=2]{code/funktionen_parameter_1.c}
				
				\textbf{Parameter und ohne Rückgabewert:}
				\lstinputlisting[language=C,tabsize=2]{code/funktionen_parameter_2.c}
			\end{minipage}
			\hspace*{0.5cm}
			\begin{minipage}[t]{8.5 cm}
				\textbf{Parameter und Rückgabewert:}
				\lstinputlisting[language=C,tabsize=2]{code/funktionen_parameter_3.c}
			\end{minipage}
			
\newpage

	\subsection{Deklaration von Funktionen \verweis{9.4}}
		Es ist festgelegt, dass die Konsistenz zwischen Funktionskopf und Funktionsaufrufen vom Compiler überprüft werden soll. Dazu muss beim Aufruf der Funktion die Schnittstelle der Funktion, d.h. der Funktionskopf, bereits bekannt sein. Steht aber die Definition einer Funktion im Programmcode erst nach ihrem Aufruf, so muss eine Vorwärtsdeklaration der Funktion erfolgen, indem vor dem Aufruf die Schnittstelle der Funktion mit dem Funktionsprototypen deklariert wird. \\
		Desweitern ist zu beachten, dass Parameternamen im Funktionsprototyp und in der Funktionsdefinition nicht übereinstimmen müssen. Es ist jedoch zu empfehlen.
		
		\begin{minipage}[t]{9.5 cm}
			\subsubsection{Beispiel}
				\lstinputlisting[language=C,tabsize=2]{code/funktionen_prototyp.c}	
		\end{minipage}
		\hspace*{0.5cm}
		\begin{minipage}[t]{7.5 cm}	
			\subsubsection{Was passiert wenn der Prototyp vergessen geht?}
				\begin{compactitem}
					\item Fehlt der Prototyp ganz, so wird die Funktion implizit (automatisch vom System) deklariert. Ihr Rückgabetyp wird als $int$ angenommen, die Parameter werden nicht überprüft.
					\item Wenn die Funktion später definiert wird und nicht $int$ als Rückgabetyp hat, bringt der Compiler eine Fehlermeldung.
				\end{compactitem}
		\end{minipage}
		
		\subsubsection{Funktionsprototypen in der Praxis \verweis{9.4}}
			\begin{compactitem}
				\item Funktionsprototypen, welche die Schnittstelle der Unit beschreiben, kommen in das entsprechenden Headerfile.
				\item Jedes C-File, welches diese Schnittstelle nutzt, inkludiert dieses Headerfile und somit die Funktionsprototypen.
				\item Funktionsprototypen von internen Funktionen der Unit werden zuoberst im C-File aufgelistet und kommen nicht ins Headerfile.
			\end{compactitem}
			
\section{Pointer und Arrays \verweis{6}}
	\begin{minipage}[t]{7 cm}
		\subsection{Arbeisspeicher - Memory Map \verweis{6.1}}
			\includegraphics[width=0.9\textwidth]{pics/arbeitsspeicher.jpg}
			
			\begin{compactitem}
				\item Der gesamte Speicher besteht aus einer Folge von einzelnen Bytes, welche durchnumeriert werden.
				\item Diese eindeutige Nummer einer Speicherzelle wird als Adresse bezeichnet.
				\item Bei einem byteweise adressierbaren Speicher (ist üblich) liegt an jeder Adresse genau 1 Byte.
			\end{compactitem}
	\end{minipage}
	\hspace*{0.5cm}
	\begin{minipage}[t]{10.5 cm}
		\subsection{Pointer \verweis{6.1}}
			\includegraphics[width=1\textwidth]{pics/pointer.jpg}
				
			\begin{compactitem}
				\item Ein Pointer ist eine Variable, welche die Adresse einer im Speicher befindlichen Variablen oder Funktion aufnehmen kann.
				\item Man sagt, der Pointer zeige (to point) auf diese Speicherzelle.
				\item Pointer in C sind typisiert, sie zeigen auf eine Variable des definierten Typs.
				\item Der Speicherbereich, auf den ein bestimmter Pointer zeigt, wird entsprechend des definierten Pointer-Typs interpretiert.
				\item Der Speicherbedarf einer Pointervariablen ist unabhängig vom Pointer-Typ. Er ist so gross, dass die maximale Adresse Platz findet (z.B. 32 Bit).
			\end{compactitem}
	\end{minipage}	
			
\newpage

	\begin{minipage}[t]{10 cm}
		\subsubsection{Definition einer Pointervariablen \verweis {6.1}}		
			\vspace*{-0.3cm}\lstinputlisting[language=C,tabsize=2]{code/pointer_init.c}
	\end{minipage}
	\hspace*{0.5cm}
	\begin{minipage}[t]{8.5 cm}
		\subsubsection{Initialisierung mit Nullpointer \verweis {6.1}}
			NULL ist vordefiniert (in $stddef.h$) und setzt den Pointer auf einen definierten Nullwert. Besser ist es, statt NULL direkt 0 zu verwenden.
			\vspace*{-0.2cm}\lstinputlisting[language=C,tabsize=2]{code/pointer_null.c}
	\end{minipage}		
			
	\begin{minipage}[t]{9 cm}
		\subsubsection{Der Adressoperator (Referenzierung) \verweis {6.1}}	
			Ist $x$ eine Variable vom Typ $Typname$, so liefert der	Ausdruck $\&x$ einen Pointer auf die Variable $x$, d.h. er liefert die Adresse der Variablen $x$.	
			\lstinputlisting[language=C,tabsize=2]{code/pointer_adressoperator.c}
	\end{minipage}
	\hspace*{0.5cm}
	\begin{minipage}[t]{9 cm}
		\subsubsection{Der Inhaltsoperator * (Dereferenzierung) \verweis {6.1}}
			Ist $ptr$ ein Pointer vom Typ $Typname$, so liefert der	Ausdruck $*ptr$ den Inhalt der Speicherzelle, auf welche $ptr$ zeigt.
			\vspace*{-0.2cm}\lstinputlisting[language=C,tabsize=2]{code/pointer_inhaltsoperator.c}
	\end{minipage}	
	
	\subsubsection{Beispiele Darstellung in graphischer Pointernotation}		
		\begin{minipage}[t]{6 cm}
			\includegraphics[width=1\textwidth]{pics/pointer_beispiel_1.jpg}
		\end{minipage}	
		%
		\begin{minipage}[t]{6 cm}
			\includegraphics[width=1\textwidth]{pics/pointer_beispiel_2.jpg}
		\end{minipage}	
		%
		\begin{minipage}[t]{6 cm}
			\includegraphics[width=1\textwidth]{pics/pointer_beispiel_3.jpg}
		\end{minipage}
		
	\subsubsection{Pointerarithmetik \verweis{10.1.1}}
		\begin{minipage}[t]{9 cm}
			\textbf{Zuweisung:} 
			\begin{compactitem}
				\item Pointer unterschiedlicher Datentypen dürfen einander nicht zugewiesen werden (Schutzmechanismus).
				\item Einem Pointer eines bestimmten Typs dürfen Pointer dieses Typs oder void-Pointer zugewiesen werden.
				\item Einem void-Pointer dürfen beliebige Pointer zugewiesen werden (nützlich aber gefährlich).
			\end{compactitem}
			\ \\
			\textbf{Vergleiche:} 
			\begin{compactitem}
				\item Bei Pointern desselben Typs funktionieren Vergleiche wie $==$, $!=$, $<$, $>$, $>=$, etc.
				\item Hintergrund: ein Pointer ist eine Adresse, d.h. die Vergleiche passieren mit den Adressen. Daraus ist klar, was die Vergleiche bewirken.
			\end{compactitem}
		\end{minipage}	
		\hspace*{0.5cm}
		\begin{minipage}[t]{9 cm}
			\textbf{Addition und Subtraktion:} 
				\begin{compactitem}
					\item Zu einem Pointer darf eine ganze Zahl oder ein anderer Pointer desselben Typs addiert werden.
					\item Von einem Pointer kann eine ganze Zahl oder ein anderer Pointer desselben	Typs subtrahiert werden.
					\item Wenn eine ganze Zahl n addiert / subtrahiert wird, so bewegt sich der Pointer	auf das nächste Element des Pointertyps. Die Zahl n wird also nicht als Byte interpretiert, der Pointer bewegt sich um $n*sizeof(Typ)$ Bytes.
				\end{compactitem}
				\ \\
				\textbf{Andere Operationen:} 
				\begin{compactitem}
					\item Andere Operationen sind nicht erlaubt!
				\end{compactitem}
		\end{minipage}	

\newpage

	\subsection{Arrays \verweis{6.3}}
		Ein Array bietet eine kompakte Zusammenfassung von mehreren Variablen des gleichen Typs.
		
		\begin{minipage}[t]{10.5 cm}
			\subsubsection{Definition eines Arrays \verweis{6.3}}
				\vspace*{-0.3cm}\lstinputlisting[language=C,tabsize=2]{code/array_init.c}
				
			\subsubsection{Zeichenketten (Strings) \verweis{6.3}}
				\begin{compactitem}
					\item Ein String ist in C ein Array von Zeichen (char-Array).
					\item Ein String muss in C immer mit dem Nullzeichen $'\backslash0'$ \\
					abgeschlossen werden. Dieses benötigt eine Stelle im Array!					
				\end{compactitem}
				\lstinputlisting[language=C,tabsize=2]{code/array_string.c}
		\end{minipage}	
		%
		\begin{minipage}[t]{8.5 cm}
			\subsubsection{Zugriff auf ein Arrayelement \verweis{6.3}}
				Der Zugriff auf ein Element eines Arrays erfolgt über den Array-Index. Ist ein Array mit n Elementen definiert, so ist darauf zu achten, dass in C der Index mit 0 beginnt und mit n-1 endet.
				\lstinputlisting[language=C,tabsize=2]{code/array_zugriff.c}
		\end{minipage}	

		\begin{minipage}[t]{9 cm}
			\subsubsection{Äquivalenz von Array- und Pointernotation \verweis{10.1}}	
				\includegraphics[width=1\textwidth]{pics/array_pointer.jpg}
				
			\subsubsection{Vergleichen von Arrays \verweis{10.1}}
			\begin{compactitem}
				\item In C gibt es keinen Operator $==$, der zwei Arrays miteinander vergleicht.
				\item Arrayvergleiche müssen explizit Element um Element durchgeführt werden oder der Inhalt der beiden Speicherbereiche wird mit Hilfe der Funktion	$memcmp()$ byteweise verglichen.
			\end{compactitem}
		\end{minipage}
		\hspace*{0.5cm}
		\begin{minipage}[t]{9 cm}	
			\subsubsection{Der Arrayname \verweis{10.1}}
				\begin{compactitem}
					\item Der Arrayname ist ein nicht modifizierbarer L-Wert.
					\item Der Arrayname ist ein konstanter Pointer auf das erste Element des Arrays und kann nicht verändert werden.
					\item Auf den Arraynamen können nur die beiden Operatoren $sizeof$ und $\&$ angewandt werden.
					\item Der Arrayname (z.B. $arr$ bei $int$ $arr[5]$), als auch der Adressoperator angewandt auf den Arraynamen ($\&arr$) ergeben einen konstanten Pointer auf das erste Element des Arrays, d.h. sie ergeben dieselbe Adresse. Der Datentyp ist allerdings unterschiedlich: \\
					Der Typ von $arr$ ist $int*$ \\
					Der Typ von $\&arr$ ist $int$ $(*)[5]$ (Pointer auf Array mit 5 int's)
					\item Einem Arraynamen kann kein Wert zugewiesen werden (einer Pointervariablen	schon).
				\end{compactitem}
		\end{minipage}
		
		\vspace*{0.1cm}
		
		\begin{minipage}[t]{9 cm}
			\subsubsection{Automatische Initialisierung \verweis{10.1.3}}	
				\begin{compactitem}
					\item Globale Arrays werden automatisch mit 0 initialisiert.
					\item Lokale Arrays werden nicht automatisch initialisiert.
				\end{compactitem}
				
			\subsubsection{Explizite Initialisierung \verweis{10.1.3}}	
				\begin{compactitem}
					\item Bei der Definition eines Arrays kann ein Array explizit ("manuell") initialisiert werden.
					\item Nach der Initialisierung können die Elemente nur noch einzeln geändert werden.
				\end{compactitem}
				\lstinputlisting[language=C,tabsize=2]{code/array_init_zuweisung.c}
				\begin{compactitem}
					\item Werden bei der Initialisierung weniger Werte angegeben als der Array Elemente hat, so werden die restlichen Elemente mit 0 belegt.
				\end{compactitem}
				\lstinputlisting[language=C,tabsize=2]{code/array_init_null.c}
				\begin{compactitem}
					\item Wird bei der Definition keine Arraygrösse angegeben, so zählt der Compiler die Anzahl Elemente automatisch (offenes Array oder Array ohne Längenangabe).
				\end{compactitem}
				\lstinputlisting[language=C,tabsize=2]{code/array_init_offen.c}
		\end{minipage}
		\hspace*{0.5cm}
		\begin{minipage}[t]{9 cm}	
			\subsubsection{Mehrdimensionale Arrays \verweis{10.1.4}}
				Das Array $int$ $alpha[3][4]$ kann folgendermassen aufgezeichnet werden: \\
				\includegraphics[width=1\textwidth]{pics/array_mehrdimensional.jpg}
			
			\subsubsection{Initialisierung eines mehrdimensionalen Arrays \verweis{10.1.4}}
				\lstinputlisting[language=C,tabsize=2]{code/array_init_mehrdimensional.c}
		\end{minipage}

\newpage 

		\subsubsection{Initialisierung von Zeichenketten \verweis{10.1.5 und Kapitel 10.1.6}}
			\lstinputlisting[language=C,tabsize=2]{code/string_init.c}
			
		\subsubsection{Übergabe von Arrays und Zeichenketten \verweis{10.2}}
			\begin{compactitem}
				\item Bei der Übergabe eines Arrays an eine Funktion wird als Argument der Arrayname übergeben (i.e. Pointer auf erstes Element des Arrays).
				\item Der formale Parameter für die Übergabe eines eindimensionalen Arrays kann ein offenes Array sein oder ein Pointer auf den Komponententyp des Arrays.
				\item Die Grösse des Arrays muss immer explizit mitgegeben werden.
				\item Zeichenketten sind char-Arrays und werden deshalb gemäss der oben erwähnten Punkte gehandhabt.
			\end{compactitem}
			\lstinputlisting[language=C,tabsize=2]{code/array_uebergabe.c}
			
		\subsubsection{Übergabe eines mehrdimensionalen Arrays}
			\lstinputlisting[language=C,tabsize=2]{code/array_uebergabe_mehrdimensional.c}
\end{document}
